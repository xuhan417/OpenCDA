# -*- coding: utf-8 -*-
""" This module contains a local planner to perform
low-level waypoint following based on PID controllers. """

# Author: Xu Han <rxx3386@ucla.edu>
# License:  TDG-Attribution-NonCommercial-NoDistrib

from collections import deque
from enum import Enum
import statistics
import math

import carla
import numpy as np

from mistgen.mist import mist_generator
from opencda.core.common.misc import distance_vehicle, draw_trajetory_points, \
    cal_distance_angle, compute_distance
from opencda.core.plan.spline import Spline2D
from opencda.core.plan.local_planner_behavior import LocalPlanner


class RLLocalPlanner(LocalPlanner):
    """
    RL Local Planner that inherits the single vehicle local planner.
    The route is updated at each step when new action (i.e., target waypoint)
    is generated by the RL model. Other function remains the same.

    """

    # Minimum distance to target waypoint as a percentage
    # (e.g. within 80% of total distance)

    def __init__(self, agent, carla_map, config_yaml):

        super(RLLocalPlanner, self).__init__(agent, carla_map, config_yaml)
        self.target_waypoint = None
        self._target_speed = None

    def set_current_plan(self, current_plan):
        """
        Sets new route plan. For RL, it is necessary to clean the previous buffer as
        the new route plan is based on the new action (i.e., target waypoint) that
        was selected by RL agent.

        Parameters
        ----------
        current_plan : list
            List of waypoints in the actual plan.

        """
        # reset buffer and queue
        self.waypoints_queue.clear()
        self._waypoint_buffer.clear()

        # trace element in plan
        for elem in current_plan:
            # update route
            self.waypoints_queue.append(elem)
            self._waypoint_buffer.append(elem)

        # update waypoint buffer

        # 1. below is opencda method, continous for stability
        # for _ in range(self._buffer_size):
        #     if self.waypoints_queue:
        #         self._waypoint_buffer.append(
        #             self.waypoints_queue.popleft())
        #
        # for RL, update waypoint buffer directly from elem,
        #       this way buffer will not include old points, less stable

    def generate_path(self, plan_time, v_init, a_init, v_end, a_end):
        """
        Generate the smooth path using MiSTGen to replace the spline generation.

        Parameters
        ----------
        plan_time

        v_init

        a_init

        v_end

        a_end

        Returns :
        ----------
        rx : list
            List of planned path points' x coordinates.

        ry : list
            List of planned path points' y coordinates.

        ryaw : list
            List of planned path points' yaw angles.

        rk : list
            List of planned path points' curvatures.

        """

        # 1. Find X and Y list for trajectory generation
        # used to save all key spline node and init start index
        x = []
        y = []

        # pop out the waypoints that may damage driving performance
        # self.buffer_filter()

        # [m] distance of each interpolated points
        ds = 0.1

        # retrieve current location, yaw angle
        current_location = self._ego_pos.location
        current_yaw = self._ego_pos.rotation.yaw

        # retrieve the corresponding waypoint of the current location
        # current_wpt = self._map.get_waypoint(current_location).next(1)[0]
        current_wpt = self._map.get_waypoint(current_location)
        end_wpt = self._waypoint_buffer[-1][0]

        # retrieve past waypoint
        previous_wpt = self._history_buffer[0][0] \
            if len(self._history_buffer) > 0 \
            else current_wpt
        prev_x = previous_wpt.transform.location.x
        prev_y = previous_wpt.transform.location.y
        # append previous position to x and y
        x.append(prev_x)
        y.append(prev_y)
        # append waypoints points
        for i in range(len(self._waypoint_buffer)):
            cur_x = self._waypoint_buffer[i][0].transform.location.x
            cur_y = self._waypoint_buffer[i][0].transform.location.y
            # filter the waypoints that are too close
            if abs(prev_x - cur_x) < 0.5 and abs(prev_y - cur_y) < 0.5:
                continue
            prev_x = cur_x
            prev_y = cur_y
            # populate x and y
            x.append(cur_x)
            y.append(cur_y)

        # 2. generate trajectory using MistGen
        # generate waypoint array based on x,y
        waypoint_ori = np.array([x, y])

        # debug stream
        print('Debug @ rl_planner, mistgen: ...')
        print('The current planned points are: ' + str(waypoint_ori))
        print('--------------------------------------------------')

        my_mist_gen = mist_generator()
        # generated trajectory (x-coordinate, y-coordinate, and timestamp)
        xxs, yys, tts = my_mist_gen.mist_2d_gen(waypoint_ori, v_init, a_init,
                                              v_end, a_end, plan_time)
        # generated velocity, acceleration, and jerk trajectory
        # note: vaj_xy = [vxx,axx,jxx,vyy,ayy,jyy]
        vxx, axx, jxx, vyy, ayy, jyy = my_mist_gen.mist_2d_vaj_gen(xxs, yys, tts)
        # find yaw angle
        yaw_rad, yaw_deg = my_mist_gen.calc_yaw(vxx, vyy)

        return xxs, yys, vxx, vyy, yaw_deg

    def run_step(
            self,
            xxs,
            yys,
            vxx,
            vyy,
            trajectory=None,
            following=False):
        """
        Execute one step of local planning which involves
        running the longitudinal and lateral PID controllers to
        follow the smooth waypoints trajectory.

        Parameters
        ----------
        rx : list
            List of planned path points' x coordinates.

        ry : list
            List of planned path points' y coordinates.

        ryaw : list
            List of planned path points' yaw angles.

        rk : list
            List of planned path points' curvatures.

        following : boolean
            Indicator of whether the vehicle is under following status.

        trajectory : list
            Pre-generated car-following trajectory only for platoon members.

        target_speed : float
            The ego vehicle's desired speed.

        Returns
        -------
        speed : float
            Next trajectory point's target speed.

        waypoint : carla.waypoint
            Next trajectory point's waypoint.

        """

        # Buffering the waypoints. Always keep the waypoint buffer alive
        if len(self._waypoint_buffer) < self.waypoint_update_freq:
            for i in range(self._buffer_size - len(self._waypoint_buffer)):
                if self.waypoints_queue:
                    self._waypoint_buffer.append(
                        self.waypoints_queue.popleft())
                else:
                    break

        # Generate the trajectory buffer based on mistgen
        default_z = self._waypoint_buffer[0][0].transform.location.z + 0.5
        for i in range(len(xxs)):
            self._trajectory_buffer.append(
                # append target waypoint
                (carla.Transform(carla.Location(xxs[i], yys[i], default_z)),
                 # append target speed
                 math.sqrt(vxx[i] ** 2 + vyy[i] ** 2)))

        # Target waypoint
        self.target_waypoint, self._target_speed = \
            self._trajectory_buffer[min(1, len(self._trajectory_buffer) - 1)]

        # Purge the queue of obsolete waypoints
        vehicle_transform = self._ego_pos
        self.pop_buffer(vehicle_transform)

        return self._target_speed, \
               self.target_waypoint.transform.location if hasattr(
                   self.target_waypoint,
                   'is_junction') else self.target_waypoint.location
